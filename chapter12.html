<!DOCTYPE html>

<html>
<head>
  <title>Scala For The Impatient -- Chapter 11</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">
              
                
                <a class="source" href="index.html">
                  index
                </a>
              
                
                <a class="source" href="chapter01.html">
                  chapter01
                </a>
              
                
                <a class="source" href="chapter02.html">
                  chapter02
                </a>
              
                
                <a class="source" href="chapter03.html">
                  chapter03
                </a>
              
                
                <a class="source" href="chapter04.html">
                  chapter04
                </a>
              
                
                <a class="source" href="chapter05.html">
                  chapter05
                </a>
              
                
                <a class="source" href="chapter06.html">
                  chapter06
                </a>
              
                
                <a class="source" href="chapter07.html">
                  chapter07
                </a>
              
                
                <a class="source" href="chapter08.html">
                  chapter08
                </a>
              
                
                <a class="source" href="chapter09.html">
                  chapter09
                </a>
              
                
                <a class="source" href="chapter10.html">
                  chapter10
                </a>
              
                
                <a class="source" href="chapter12.html">
                  chapter12
                </a>
              
                
                <a class="source" href="chapter13.html">
                  chapter13
                </a>
              
                
                <a class="source" href="chapter14.html">
                  chapter14
                </a>
              
            </div>
          </div>
        </li>
      </ul>
    
    
    
        <a class="home" href="index.html">⏎</a>
    

    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="scala-for-the-impatient-chapter-11">Scala For The Impatient – Chapter 11</h1>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h2 id="exercise-1">Exercise 1</h2>
<blockquote>
<p> Write a function <code>values(fun: (Int) =&gt; Int, low: Int, high: Int)</code> that yields a collection of function inputs and outputs in a given range. For example, <code>values(x =&gt; x * x, -5, 5)</code> should produce a collection of pairs <code>(-5, 25), (-4, 16), (-3, 9), . . . , (5, 25)</code>.</p>
</blockquote>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>here, if we use the notation <code>(_, fun(_))</code>, <code>fun(_)</code> yields a lambda vs calls fun</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">values</span></span>(fun: (<span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>, low: <span class="hljs-type">Int</span>, high: <span class="hljs-type">Int</span>) =
  (low to high).map { i =&gt; (i, fun(i)) }

values(x =&gt; x * x, <span class="hljs-number">-5</span>, <span class="hljs-number">5</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2 id="exercise-2">Exercise 2</h2>
<blockquote>
<p>How do you get the largest element of an array with reduceLeft?</p>
</blockquote>

            </div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>with generics:
<em>note</em>: <code>&lt;%</code> means “<em>can implicitly be converted to the defined type</em>“. Since <code>Int =&gt; Ordered</code> is implicit and not a direct extension, we cannot use <code>&lt;:</code>…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">largestElt</span></span>[<span class="hljs-type">T</span> &lt;% <span class="hljs-type">Ordered</span>[<span class="hljs-type">T</span>]](a: <span class="hljs-type">Array</span>[<span class="hljs-type">T</span>]) =
  a.reduceLeft((a, b) =&gt; <span class="hljs-keyword">if</span> (a &gt; b) a <span class="hljs-keyword">else</span> b)

largestElt(<span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-1</span>))</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>to work only with Int:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-1</span>).reduceLeft(_ max _)</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h2 id="exercise-3">Exercise 3</h2>
<blockquote>
<p>Implement the factorial function using to and reduceLeft, without a loop or recursion.</p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">facto</span></span>(n: <span class="hljs-type">Int</span>) = n <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> _ <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">1</span> =&gt; <span class="hljs-number">0</span>
  <span class="hljs-keyword">case</span> _ =&gt; (<span class="hljs-number">1</span> to n).reduceLeft(_ * _)
}
facto(<span class="hljs-number">0</span>)
facto(<span class="hljs-number">1</span>)
facto(<span class="hljs-number">10</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h2 id="exercise-4">Exercise 4</h2>
<blockquote>
<p> The previous implementation needed a special case when n &lt; 1. Show how you can avoid this with foldLeft.</p>
</blockquote>

            </div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>we use n to initialize the accumulator. For this to work, we need to loop from 1 to n-1, not from 1 to n ! Hence the use of <code>until</code> instead of <code>to</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">facto2</span></span>(n: <span class="hljs-type">Int</span>) = (<span class="hljs-number">1</span> until n).foldLeft(n)(_ * _)

facto2(<span class="hljs-number">0</span>)
facto2(<span class="hljs-number">1</span>)
facto2(<span class="hljs-number">10</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <h2 id="exercise-5">Exercise 5</h2>
<blockquote>
<p>Write a function <code>largest(fun: (Int) =&gt; Int, inputs: Seq[Int])</code> that yields the largest value of a function within a given sequence of inputs. For example, <code>largest(x =&gt; 10 * x - x * x, 1 to 10)</code> should return 25. Don’t use a loop or recursion.</p>
</blockquote>

            </div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>very smooth and efficient</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">largest</span></span>(fun: (<span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>, inputs: <span class="hljs-type">Seq</span>[<span class="hljs-type">Int</span>]) =
  inputs.map(fun).max

largest(x =&gt; <span class="hljs-number">10</span> * x - x * x, <span class="hljs-number">1</span> to <span class="hljs-number">10</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>with fold: here, fun(x) is computed potentially multiple times for each input…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">largestFold</span></span>(fun: (<span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>, inputs: <span class="hljs-type">Seq</span>[<span class="hljs-type">Int</span>]) =
  inputs.foldLeft(<span class="hljs-type">Int</span>.<span class="hljs-type">MinValue</span>) { (acc, in) =&gt; <span class="hljs-keyword">if</span> (fun(in) &gt; acc) fun(in) <span class="hljs-keyword">else</span> acc }

largestFold(x =&gt; <span class="hljs-number">10</span> * x - x * x, <span class="hljs-number">1</span> to <span class="hljs-number">10</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <h2 id="exercise-6">Exercise 6</h2>
<blockquote>
<p> Modify the previous function to return the input at which the output is largest.</p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">largestInput</span></span>(fun: (<span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>, inputs: <span class="hljs-type">Seq</span>[<span class="hljs-type">Int</span>]) =
  inputs.map { i =&gt; (fun(i), i) }.max._2

largestInput(x =&gt; <span class="hljs-number">10</span> * x - x * x, <span class="hljs-number">1</span> to <span class="hljs-number">10</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>here, we can use reduce, since both acc and inputs are the same</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">largestInputFold</span></span>(fun: (<span class="hljs-type">Int</span>) =&gt; <span class="hljs-type">Int</span>, inputs: <span class="hljs-type">Seq</span>[<span class="hljs-type">Int</span>]) =
  inputs.reduce { (a, b) =&gt; <span class="hljs-keyword">if</span> (fun(a) &gt; fun(b)) a <span class="hljs-keyword">else</span> b }

largestInputFold(x =&gt; <span class="hljs-number">10</span> * x - x * x, <span class="hljs-number">1</span> to <span class="hljs-number">10</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <h2 id="exercise-7">Exercise 7</h2>
<blockquote>
<p>Write a function <code>adjustToPair</code> that receives a function of type (Int, Int) =&gt; Int and returns the equivalent function that operates on a pair. For example, <code>adjustToPair(_ * _)((6, 7))</code> is 42.</p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">val</span> pairs = (<span class="hljs-number">1</span> to <span class="hljs-number">10</span>) zip (<span class="hljs-number">11</span> to <span class="hljs-number">20</span>)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">adjustToPair</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](fun: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">C</span>)(pair: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>)): <span class="hljs-type">C</span> =
  pair <span class="hljs-keyword">match</span> {<span class="hljs-keyword">case</span> (a, b) =&gt; fun(a, b)}</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>since we use generics, we need to tell the compiler what the types are in the partial function…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>adjustToPair((_: <span class="hljs-type">Int</span>) * (_: <span class="hljs-type">Int</span>))((<span class="hljs-number">6</span>, <span class="hljs-number">7</span>)) <span class="hljs-comment">//&gt; 42</span>
pairs.map(adjustToPair(_ + _)) <span class="hljs-comment">//&gt; (12, 14, 16, 18, 20, 22, 24, 26, 28, 30)</span></pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <h2 id="exercise-8">Exercise  8</h2>
<blockquote>
<p> Make a call to corresponds (see page 149) that checks whether the elements in an array of strings have the lengths given in an array of integers.</p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">val</span> arrayOfString = <span class="hljs-type">Array</span>(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"world"</span>, <span class="hljs-string">"!"</span>, <span class="hljs-string">":)"</span>)
<span class="hljs-keyword">val</span> lengthOfStrings = arrayOfString.map(_.length)

arrayOfString.corresponds(lengthOfStrings)(_.length == _)</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <h2 id="exercise-9">Exercise 9</h2>
<p>Implement corresponds without currying. Then try the call from the preceding exercise. What problem do you encounter?</p>

            </div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Two main problems:</p>

            </div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <ol>
<li>since the function has 3 parameters, we cannot use the infix notation, i.e. x corresponds y</li>
<li>type inference is not working properly, we have to specify the types in the lambda function</li>
</ol>
<p>With currying, both those problems are solved.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myCorresponds</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](in1: <span class="hljs-type">Seq</span>[<span class="hljs-type">A</span>], in2: <span class="hljs-type">Seq</span>[<span class="hljs-type">B</span>], fun: (<span class="hljs-type">A</span>, <span class="hljs-type">B</span>) =&gt; <span class="hljs-type">Boolean</span>) = in1.zip(in2).forall(t =&gt; fun(t._1, t._2))

myCorresponds(arrayOfString, lengthOfStrings, (a: <span class="hljs-type">String</span>, b: <span class="hljs-type">Int</span>) =&gt; a.length == b)</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <h2 id="exercise-10">Exercise 10</h2>
<blockquote>
<p> Implement an unless control abstraction that works just like if, but with an inverted condition. Does the first parameter need to be a call-by-name parameter? Do you need currying?</p>
</blockquote>

            </div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Currying let’s you write something that is more like the <code>if</code> statement. But it is not needed per se.</p>

            </div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>recall that <code>: =&gt;</code> means a call-by-name</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unless</span></span>(condition: =&gt; <span class="hljs-type">Boolean</span>)(body: =&gt; <span class="hljs-type">Unit</span>) =
  <span class="hljs-keyword">if</span> (!condition) body

unless(<span class="hljs-number">0</span> == <span class="hljs-number">1</span>) {
  println(<span class="hljs-string">"it works !"</span>)
}</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>notice that we <em>have to</em> use the curly brackets. It is still a function call, so
<code>unless(x) println()</code> won’t work.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">for</span> (i &lt;- (<span class="hljs-number">0</span> to <span class="hljs-number">5</span>)) unless(i == <span class="hljs-number">3</span>) {println(i)}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
